defmodule Generator do
  defp __priv_path__, do: Path.join(Mix.Project.build_path(), "/priv")
  def priv_path(name), do: Path.join(__priv_path__(), name)

  defp __template_path__, do: Path.join(Mix.Project.build_path(), "/priv/template")
  def template_path(name), do: Path.join(__template_path__(), name)

  defp __output_path__, do: Path.join(Mix.Project.build_path(), "/priv/cmake")
  def output_path(name), do: Path.join(__output_path__(), name)

  defp __nif_path__, do: Path.join(File.cwd!(), "priv")
  def nif_path(name), do: Path.join(__nif_path__(), name)

  def run(hardware) do
    bit = "#{Map.get(hardware, "bit", 8)}"

    hardware =
      %{
        "bit" => bit
      }

    directories =
      File.ls!(template_path("src"))
      |> Enum.map(&Path.join(template_path("src"), &1))
      |> Enum.filter(&File.dir?/1)
      |> Enum.map(&Path.basename(&1))

    Enum.map(directories, &compile_dir(hardware, &1))

    IO.puts("Generating files...")

    cmake_dir =
      directories
      |> Enum.map(
        &"""
        add_subdirectory(#{&1})
        """
      )
      |> Enum.join("")

    hardware = Map.put(hardware, "directories", cmake_dir)
    __compile__(hardware, "CMakeLists.txt")
  end

  def compile_dir(hardware, path) do
    File.mkdir_p!(__output_path__() <> "/#{path}/nif")

    bit = Map.get(hardware, "bit")

    hardware =
      hardware
      |> Map.put("op", path)
      |> Map.put("nif_module", Atom.to_string(Generator.Nif.module_name(bit, path)))

    template_files = [
      "#{path}_wrapper.sv",
      "#{path}.h",
      "#{path}.cpp",
      "nif/#{path}.cpp"
    ]

    compile(hardware, template_files)

    __compile__(
      hardware,
      template_path("lists/CMakeLists.txt"),
      output_path("#{path}/CMakeLists.txt")
    )

    __compile__(
      hardware,
      template_path("lists/nif/CMakeLists.txt"),
      output_path("#{path}/nif/CMakeLists.txt")
    )

    compile_nif(hardware, path)
  end

  def compile_nif(hardware, path) do
    %{
      "bit" => bit
    } = hardware

    hardware =
      Map.put(hardware, "nif_module", Atom.to_string(Generator.Nif.module_name(bit, path)))

    File.mkdir_p!("priv")
    file_name = "priv/#{path}.ex"

    so = priv_path("#{path}")

    string =
      File.read!(output_path(path <> "/nif/#{path}.cpp"))

    regex = ~r/\s*{"clk",\s+(\d)/

    [_, ret] = Regex.run(regex, string)

    args = for i <- 1..String.to_integer(ret), do: Macro.var(:"_arg#{i}", __MODULE__)

    ast =
      quote do
        defmodule unquote(Generator.Nif.module_name(bit, path)) do
          @doc """
          This file is autogenerated.
          """
          @on_load :load_nifs

          def load_nifs do
            so = unquote(so)

            :erlang.load_nif(~c"#{so}", 0)
          end

          def create(_name) do
            raise "NIF create/2 not implemented"
          end

          def clk(unquote_splicing(args)) do
            raise "NIF clk/#{unquote(length(args))} not implemented"
          end
        end
      end

    File.write!(file_name, Macro.to_string(ast))
    # Code.compile_file(file_name)
  end

  def compile(hardware, template_files) do
    template_files
    |> Enum.map(&__compile_dynamic_path__(hardware, &1))
  end

  defp __compile_dynamic_path__(hardware, file) do
    %{
      "bit" => bit,
      "op" => op
    } = hardware

    fin_path = template_path("src/#{op}/#{file}")
    fout_path = output_path("#{op}/#{file}")

    __compile__(hardware, fin_path, fout_path)
  end

  defp __compile__(hardware, fin_path, fout_path) do
    embed_parameters!(hardware, fin_path)
    |> then(&File.write!(fout_path, &1))
  end

  defp __compile__(hardware, fin_path) do
    __compile__(hardware, template_path(fin_path), output_path(fin_path))
  end

  @doc """
  パラメーターを埋め込む
  """
  def embed_parameters!(hardware, path) do
    File.read!(path)
    |> then(
      &Regex.replace(~r/#\{(\w+)\}/, &1, fn _, key ->
        Map.get(hardware, key, "")
      end)
    )
  end
end
