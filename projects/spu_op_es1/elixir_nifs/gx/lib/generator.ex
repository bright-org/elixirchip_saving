defmodule Generator do
  defp __priv_path__, do: Path.join(Mix.Project.build_path(), "/priv")
  def priv_path(name), do: Path.join(__priv_path__(), name)

  defp __template_path__, do: Path.join(Mix.Project.build_path(), "/priv/template")
  def template_path(name), do: Path.join(__template_path__(), name)

  defp __output_path__, do: Path.join(Mix.Project.build_path(), "/priv/cmake")
  def output_path(name), do: Path.join(__output_path__(), name)

  defp __nif_path__, do: Path.join(File.cwd!(), "priv")
  def nif_path(name), do: Path.join(__nif_path__(), name)

  def run() do
    bit = 4

    if(File.exists?(__priv_path__())) do
      File.ls!(__priv_path__())
      |> Enum.map(&Path.join(__priv_path__(), &1))
      |> Enum.filter(&File.regular?(&1))
      |> Enum.map(&File.rm!(&1))
    end

    File.mkdir_p(__output_path__() <> "/spu/acc_#{bit}bit")
    File.mkdir_p(__output_path__() <> "/spu_nif/acc_#{bit}bit")

    if(File.exists?(__nif_path__())) do
      File.rm_rf!(__nif_path__())
    end

    File.mkdir_p(__nif_path__())

    IO.puts("Generating files...")

    hardware =
      %{
        "bit" => "#{bit}",
        "op" => "acc",
        "nif_module" => Atom.to_string(Generator.Nif.module_name(bit, "acc"))
      }

    template_files = [
      {"wrapper.sv", "spu"},
      {"wrapper.h", "spu"},
      {"wrapper.cpp", "spu"},
      {"call.cpp", "spu_nif"}
    ]

    compile_nif(hardware)
    compile(hardware, template_files)
    __compile__(hardware, "CMakeLists.txt")
    __compile__(hardware, "spu/CMakeLists.txt")
    __compile__(hardware, "spu/acc/CMakeLists.txt", "spu/acc_#{bit}bit/CMakeLists.txt")
    __compile__(hardware, "spu_nif/CMakeLists.txt")
    __compile__(hardware, "spu_nif/acc/CMakeLists.txt", "spu_nif/acc_#{bit}bit/CMakeLists.txt")
  end

  def compile_nif(hardware) do
    %{
      "bit" => bit,
      "op" => op,
      "nif_module" => _module_name
    } = hardware

    op_name =
      String.downcase(op) <> "_clk"

    file_name = nif_path("#{Macro.underscore(Generator.Nif.module_name(bit, op))}.ex")

    unless(File.exists?(Path.dirname(file_name))) do
      File.mkdir_p!(Path.dirname(file_name))
    end

    so = priv_path("#{op}_#{bit}bit")

    ast =
      quote do
        defmodule unquote(Generator.Nif.module_name(bit, op)) do
          @doc """
          This file is autogenerated.
          """
          @on_load :load_nifs

          def load_nifs do
            so = unquote(so)

            :erlang.load_nif(~c"#{so}", 0)
          end

          def create(_name) do
            raise "NIF create/2 not implemented"
          end

          def clk(
                _resource,
                _s_sub,
                _s_carry,
                _s_data,
                _s_clear,
                _s_valid,
                _m_carry,
                _m_data
              ) do
            raise "NIF clk/8 not implemented"
          end
        end
      end

    File.write!(file_name, Macro.to_string(ast))
    # Code.compile_file(file_name)
  end

  def compile(hardware, template_files) do
    template_files
    |> Enum.map(&__compile_dynamic_path__(hardware, &1))
  end

  defp __compile_dynamic_path__(hardware, {path, dir}) do
    %{
      "bit" => bit,
      "op" => op
    } = hardware

    fin_path =
      "#{dir}/#{op}/#{path}"

    fout_path =
      "#{dir}/#{op}_#{bit}bit/#{op}_#{bit}bit#{Path.extname(path)}"

    __compile__(hardware, fin_path, fout_path)
  end

  defp __compile__(hardware, fin_path, fout_path) do
    embed_parameters!(hardware, fin_path)
    |> then(&File.write(output_path(fout_path), &1))
  end

  defp __compile__(hardware, fin_path) do
    __compile__(hardware, fin_path, fin_path)
  end

  @doc """
  パラメーターを埋め込む
  """
  def embed_parameters!(hardware, path) do
    File.read!(template_path(path))
    |> then(
      &Regex.replace(~r/#\{(\w+)\}/, &1, fn _, key ->
        Map.get(hardware, key, "")
      end)
    )
  end
end
